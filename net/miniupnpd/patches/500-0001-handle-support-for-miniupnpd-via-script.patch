From aea82bb99791213073c7bdc9d841a85fc4a9b6d5 Mon Sep 17 00:00:00 2001
From: Chen Minqiang <ptpt52@gmail.com>
Date: Sun, 13 Mar 2022 11:33:39 +0800
Subject: [PATCH] handle support for miniupnpd via script

---
 netfilter_nft/nftnlrdr.c      | 54 +++++++++++++++++++++++++++++++++++
 netfilter_nft/nftnlrdr_misc.c | 23 +++++++++++----
 netfilter_nft/nftnlrdr_misc.h |  1 +
 3 files changed, 73 insertions(+), 5 deletions(-)

--- a/netfilter_nft/nftnlrdr.c
+++ b/netfilter_nft/nftnlrdr.c
@@ -47,6 +47,23 @@
 
 #include "nftnlrdr_misc.h"
 
+void call_miniupnpd_add_rule(const char *ifname, const char *iaddr, unsigned short iport, unsigned short eport, int proto)
+{
+	char cmd[256];
+	sprintf(cmd, "test -e /usr/share/miniupnpd/core.sh && "
+			"sh /usr/share/miniupnpd/core.sh addrule %s %s %u %u %s",
+			ifname, iaddr, iport, eport, proto == IPPROTO_UDP ? "udp" : "tcp");
+	system(cmd);
+}
+void call_miniupnpd_del_rule(unsigned short eport, int proto)
+{
+	char cmd[256];
+	sprintf(cmd, "test -e /usr/share/miniupnpd/core.sh && "
+			"sh /usr/share/miniupnpd/core.sh delrule %u %s",
+			eport, proto == IPPROTO_UDP ? "udp" : "tcp");
+	system(cmd);
+}
+
 #ifdef DEBUG
 #define d_printf(x) do { printf x; } while (0)
 #else
@@ -75,6 +92,8 @@ init_redirect(void)
 	/* requires elevated privileges */
 	result = nft_mnl_connect();
 
+	return 0;
+
 	/* 'inet' family */
 	if (result == 0) {
 		result = table_op(NFT_MSG_NEWTABLE, NFPROTO_INET, nft_table);
@@ -118,6 +137,10 @@ shutdown_redirect(void)
 {
 	int result;
 
+	nft_mnl_disconnect();
+
+	return 0;
+
 	/* 'inet' family */
 	result = chain_op(NFT_MSG_DELCHAIN, NFPROTO_INET, nft_table,
 					  nft_forward_chain, FILTER_CHAIN_TYPE, NF_INET_FORWARD, NF_IP_PRI_FILTER - 25);
@@ -256,6 +279,13 @@ add_redirect_rule2(const char * ifname,
 	d_printf(("add redirect rule2(%s, %s, %u, %s, %u, %d, %s)!\n",
 	          ifname, rhost, eport, iaddr, iport, proto, desc));
 
+	call_miniupnpd_add_rule(ifname, iaddr, iport, eport, proto);
+	refresh_nft_cache_set_invalid();
+
+	add_timestamp_entry(eport, proto, timestamp);
+
+	return 0;
+
 	r = rule_set_dnat(NFPROTO_IPV4, ifname, proto,
 	                  0, eport,
 	                  inet_addr(iaddr), iport,  desc, NULL);
@@ -285,6 +315,13 @@ add_peer_redirect_rule2(const char * ifn
 
 	d_printf(("add peer redirect rule2()!\n"));
 
+	call_miniupnpd_add_rule(ifname, iaddr, iport, eport, proto);
+	refresh_nft_cache_set_invalid();
+
+	add_timestamp_entry(eport, proto, timestamp);
+
+	return 0;
+
 	r = rule_set_snat(NFPROTO_IPV4, proto,
 	                  inet_addr(rhost), rport,
 	                  inet_addr(eaddr), eport,
@@ -311,6 +348,8 @@ add_filter_rule2(const char * ifname,
 	d_printf(("add_filter_rule2(%s, %s, %s, %d, %d, %d, %s)\n",
 	          ifname, rhost, iaddr, eport, iport, proto, desc));
 
+	return 0;
+
 	if (rhost != NULL && strcmp(rhost, "") != 0 && strcmp(rhost, "*") != 0) {
 		rhost_addr = inet_addr(rhost);
 	}
@@ -347,6 +386,8 @@ delete_filter_rule(const char * ifname,
 	struct nftnl_rule *r;
 	UNUSED(ifname);
 
+	return 0;
+
 	refresh_nft_cache_filter();
 	LIST_FOREACH(p, &head_filter, entry) {
 		if (p->eport == port && p->proto == proto && p->type == RULE_FILTER) {
@@ -371,6 +412,14 @@ delete_redirect_and_filter_rules(unsigne
 	uint16_t iport = 0;
 
 	d_printf(("delete_redirect_and_filter_rules(%d %d)\n", eport, proto));
+
+	call_miniupnpd_del_rule(eport, proto);
+	refresh_nft_cache_set_invalid();
+
+	remove_timestamp_entry(eport, proto);
+
+	return 0;
+
 	refresh_nft_cache_redirect();
 
 	// Delete Redirect Rule
@@ -763,6 +812,11 @@ update_portmapping(const char * ifname,
 
 	d_printf(("update_portmapping()\n"));
 
+	call_miniupnpd_add_rule(ifname, iaddr_str, iport, eport, proto);
+	refresh_nft_cache_set_invalid();
+
+	return 0;
+
 	if (get_redirect_rule(NULL, eport, proto, iaddr_str, INET_ADDRSTRLEN, NULL, NULL, 0, rhost, INET_ADDRSTRLEN, NULL, 0, 0) < 0)
 		return -1;
 
--- a/netfilter_nft/nftnlrdr_misc.c
+++ b/netfilter_nft/nftnlrdr_misc.c
@@ -63,10 +63,10 @@
 #define RULE_CACHE_INVALID  0
 #define RULE_CACHE_VALID    1
 
-const char * nft_table = "miniupnpd";
-const char * nft_prerouting_chain = "prerouting";
-const char * nft_postrouting_chain = "postrouting";
-const char * nft_forward_chain = "forward";
+const char * nft_table = "fw4";
+const char * nft_prerouting_chain = "dstnat";
+const char * nft_postrouting_chain = "srcnat";
+const char * nft_forward_chain = "forward_wan";
 
 static struct mnl_socket *mnl_sock = NULL;
 static uint32_t mnl_portid = 0;
@@ -249,6 +249,10 @@ parse_rule_meta(struct nftnl_expr *e, ru
 		reg_type = RULE_REG_IIF;
 		set_reg(r, dreg, reg_type, 0);
 		break;
+	case NFT_META_L4PROTO:
+		reg_type = RULE_REG_IP_PROTO;
+		set_reg(r, dreg, reg_type, 0);
+		break;
 	default:
 		log_debug("parse_rule_meta :Not support key %d\n", key);
 		break;
@@ -614,6 +618,13 @@ table_cb(const struct nlmsghdr *nlh, voi
 }
 #undef CB_DATA
 
+int refresh_nft_cache_set_invalid(void)
+{
+	rule_list_filter_validate = RULE_CACHE_INVALID;
+	rule_list_peer_validate = RULE_CACHE_INVALID;
+	rule_list_redirect_validate = RULE_CACHE_INVALID;
+}
+
 int
 refresh_nft_cache_filter(void)
 {
@@ -640,7 +651,7 @@ int
 refresh_nft_cache_redirect(void)
 {
 	if (rule_list_redirect_validate != RULE_CACHE_VALID) {
-		if (refresh_nft_cache(&head_redirect, nft_table, nft_prerouting_chain, NFPROTO_IPV4, RULE_NAT) < 0)
+		if (refresh_nft_cache(&head_redirect, nft_table, nft_prerouting_chain, NFPROTO_INET, RULE_NAT) < 0)
 			return -1;
 		rule_list_redirect_validate = RULE_CACHE_VALID;
 	}
@@ -1283,6 +1294,8 @@ chain_op(enum nf_tables_msg_types op, ui
 
 	struct nftnl_chain *chain;
 
+	return 0;
+
 	// log_debug("(%d, %d, %s, %s, %s, %d, %d)", op, family, table, name, type, hooknum, priority);
 
 	chain = nftnl_chain_alloc();
--- a/netfilter_nft/nftnlrdr_misc.h
+++ b/netfilter_nft/nftnlrdr_misc.h
@@ -139,6 +139,7 @@ int refresh_nft_cache_filter(void);
 int refresh_nft_cache_redirect(void);
 int refresh_nft_cache_peer(void);
 int refresh_nft_cache(struct rule_list *head, const char *table, const char *chain, uint32_t family, enum rule_type type);
+int refresh_nft_cache_set_invalid(void);
 
 int
 table_op(enum nf_tables_msg_types op, uint16_t family, const char * name);
